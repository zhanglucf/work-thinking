# :star: :star::star:Redis 底层存储String类型是怎么存储的？

> [String在redis底层如何存储](https://blog.csdn.net/Iliost/article/details/107034041)
>
> redis是C语言开发的，但是没直接采用c语言的字符串类型，而是自己构建了 **动态字符串(SDS)** 的抽象类型
>
> ​	struct sdshdr{ int len;//字符串长度 int free;//未使用长度 char buf[];//字符数组 }
>
> SDS与字符串的区别:
>
> ​	1.1 计数方式不同  C语言对于字符串的统计，完全来自遍历，从头遍历到末尾，知道发现空字符串就停止，这样统计出来的字符串长度时间复杂度为O(n)
>
> ​			SDS会保留长度信息，免去每次遍历获取字符串长度。所以redis速度提升了
>
> ​	1.2 杜绝缓冲区溢出
>
> ​		  字符串拼接的时候，由于c语言没有记录字符串长度，没有提前计算好内存，调用拼接函数的时候可能会产生缓存区溢出。
>
> ​		 SDS根据free判断是否可以存放拼接的字符串，如果不够进行扩容。
>
> ​	1.3 二进制安全
>
> ​		C语言根据空字符串判断字符长度，但是图片，音频，视频，压缩文件的二进制文件会穿插空字符串在中间。
>
> ​		Redis由于保存了字符串的长度, 避免判断空字符，直接判断长度，所以redis也经常被我们拿来保存各种二进制数据。



# :star:GateWay路由规则是什么？

> 依靠断言进行路由
>
> 有一些内置的断言，例如：可以根据path  cookie  header  method  before after host
>
> 此外我们也可以自定义断言:具体做法  我们可以写一个类继承 AbstractRoutePredicateFactory这个类，重写相关的方法。



# :star::star:GateWay 你们有的是什么路由规则？

>回答轮询，就会问  如果其中一个节点宕机了怎么办。
>
>我们的<font color='red'>网关是集成Ribbon的，需要ribbon对服务进行健康检查</font>
>
>**首先微服务需要有个rest接口，就叫做heath接口吧，调用heath接口返回ok表明服务正常。**
>**gateway需要有调用heath接口的功能，并且配置到ribbon可以不断调用该接口，时刻检查服务的状态，**
>**如果有服务器挂掉，可以很快感知到，并把该服务剔除可用服务列表。**



# :star::star:过滤器与拦截器的区别？

> **正常场景`拦截器`执行流程**
>
> > 1. ==interceptor1-`preHandle`==
> > 2. interceptor2-`preHandle`
> > 3. target method
> > 4. interceptor2-`postHandle`
> > 5. ==intercepter1-`postHandle`==
> > 6. interceptor2-`afterCompletion`
> > 7. ==interceptor1-`afterCompletion`==
>
> **如果目标方法出现异常，`拦截器`执行流程：**
>
> > 1. ==interceptor1-`preHandle`==
> > 2. interceptor2-`preHandle`
> > 3. target method
> > 4. interceptor2-`afterCompletion`
> > 5. ==interceptor1-`afterCompletion`==
>
> **过滤器`、`拦截器`、`aop的区别？**
>
> - 过滤器是`J2EE`规范，`servlet`2.3开始引入。多个过滤器形成过滤器链，过滤器执行顺序取决于`web.xml`中定义的顺序。
> - 拦截器的概念基于`springmvc`,基于反射机制，代理模式实现。
> - `AOP`是`OOP`的补充，用于降低业务逻辑各部分之间的耦合度，提高程序的可重用性。只能应用于由 `Spring `容器管理的` bean`
> - 三者执行顺序：` 过滤器 `-> `拦截器` -> `AOP`
>
> 自定义拦截器：
>
> ``` 
> 实现HandlerInterceptor接口，<mvc:interceptors>  <mvc:mapping>等相关标签进行声明。
> ```
>
> 
>
> 原理实现上：过滤器基于回调实现，而拦截器基于动态代理。
> 控制粒度上：过滤器和拦截器都能够实现对请求的拦截功能，但是在拦截的粒度上有较大的差异，拦截器对访问控制的粒度更细。
> 使用场景上：拦截器往往用于权限检查、日志记录等，过滤器主要用于过滤请求中无效参数，安全校验。
> 依赖容器上：过滤器依赖于Servlet容器，局限于web，而拦截器依赖于Spring框架，能够使用Spring框架的资源，不仅限于web。
> 触发时机上：过滤器在Servlet前后执行，拦截器在handler前后执行，现在大多数web应用基于Spring，拦截器更细。



# :star::star::star:spring循环依赖是怎么解决的？

> singletonObjects，一级缓存，存储的是所有<font color='red'>创建好了的单例Bean</font>
> earlySingletonObjects，二级缓存，<font color='red'>完成实例化，但是还未进行属性注入及初始化的对象</font>
> singletonFactories，三级缓存，<font color='red'>提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象</font>
>
> 
>
> **面试官：”为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？“**
>
> 答：如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过`AnnotationAwareAspectJAutoProxyCreator`这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。



# :star::star:唯一索引和普通索引有什么区别？

> 1. 在数据的查询方面，性能上微乎其微。 这个可以扯数据页
> 2. 在数据更新上，普通索引性能相对来说好一些。这个扯change buffer，新操作先记录在change buffer，减少读磁盘。唯一索引用不到changebuffer



## jdk8 lamdba底层实现看过吗？

> jvm底层解析成私有静态方法和匿名内部类型



## jdk8的并行流底层如何实现的你了解吗？

> ForkJoinPool 这个线程池的**默认线程个数是cpu 数量-1**

# 介绍下你们项目的整体架构吧？





# 你知道分页插件底层原理吗？

> 实际做的事情是在 ThreadLocal中设置了分页参数，之后在查询执行的时候，获取当线程中的分页参数，执行查询的时候通过拦截器在sql语句中添加分页参数，之后实现分页查询，查询结束后在 finally 语句中清除ThreadLocal中的查询参数。
>
> 最核心的逻辑在 PageInterceptor 中，PageInterceptor 是一个拦截器。
>
> ### Mybatis四个拦截机会
>
> 1. Executor
> 2. ParameterHandler
> 3. ResultSetHandler
> 4. StatementHandler
>
> 分页插件拦截的是 Executor ，也就是在sql执行的时候



# 说一说AOP的实现原理？

> 基于动态代理   
>
> 如果被代理类有接口，模式使用jdk动态代理实现，否则使用cglib实现动态代理。
>
> jdk动态代理是动态生成接口的实现类，而cglib是动态生成要代理类的子类。



你知道spring事务@Transactional注解的原理吗？



spring 中Bean的初始化过程？



# :star::star:springboot中你常用的注解有哪些？

```java
@SpringBootApplication
@Configuration
@Bean
@ConfigurationProperties
@Value
@RestController
@ControllerAdvice
@GetMapping ....
@ComponentScan
```



# :star::star:手动创建的线程池

> 如果核心线程数是5，最大线程数是10，阻塞队列的大小是100，这个时候过来100个任务，开始的时候阻塞队列中的任务是多少个？
>
> 95





mybatis 二级缓存和一级缓存？

> 其中一级缓存基于SqlSession实现，而二级缓存基于Mapper实现。
>
> 二级开启：在配置Mapper文件中，通过useCache属性指定Mapper执行时是否使用缓存，这个也是默认开启的。

# :star::star::star:拦截器用过吗？原理是什么？

> SpringMVC 拦截器也是Aop(面向切面)思想构建，但不是 Spring Aop 动态代理实现的， 
>
> 主要采用责任链和适配器的设计模式来实现，直接嵌入到 SpringMVC 入口代码里面。
>
> DispatcherServlet 执行调用 doService(request, response) 作为 Servlet 主要执行者， doService(request, response) 通过调用 doDispatch(request, response) 来真正执行请求处理 doDispatch(request, response) 中完成拦截器的添加和拦截器拦截处理

# :star:动态代理怎么用？

```
jdk  InvocationHandler  proxy
cglib   methodintercepter
```



# :star::star:你在项目中是如何使用aop的？

>  做日志统计 做权限管理  
>
>   我是自定义注解配合这aop一起用。
>
> > 第一步，自定义一个注解，比如LogOperate。问我怎么定义的？当然是使用元注解了  
> >
> > ```
> > @Target({ElementType.METHOD, ElementType.TYPE})
> > @Retention(RetentionPolicy.RUNTIME)
> > --元注解一共四个，剩下的还有document、inherited
> > ```
> >
> > 第二步，自定义Aspect类
> >
> > ```java
> >    //自定义一个Aspect类
> > 	 //类中定义pointCut，切入点表达式可以指定匹配我们自定义的哪个注解
> >    @Pointcut("@annotation(com.xietong.phoenix.userservice.aspect.OperationLog)")
> >     public void logPointCut() {
> >     }
> >     //去定义各种通知
> > 		 @Around("logPointCut()")
> >     public Object around(ProceedingJoinPoint point) throws Throwable {}
> >     @AfterThrowing(pointcut = "logPointCut()", throwing = "e")
> >     public void afterThrowing(Throwable e) {}
> > ```

