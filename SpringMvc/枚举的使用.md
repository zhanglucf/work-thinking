### 1、使用`@RequestBody`注解接收参数

> client端传入的参数，如何转成枚举？
>
> 使用到了`@JsonCreator`注解 
>
> 要求使用该注解的方法必须是`public`修饰且是`static`修饰的静态方法
>
> 这个方法最终会被springmvc内部的对象调用，从而将字符转换成枚举

```java

import com.cetccloud.handler.BaseEnum;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;

/**
 * @author ZhangZhenhua
 * @date 2021/1/19 8:48
 */
public enum MeetingStateEnum implements BaseEnum {
    NOT_START(0, "notStart", "未开始"),
    UNDERWAY(1, "underway", "进行中"),
    COMPLETE(2, "complete", "完成");

    private Integer value;
    private String desc;
    private String descCN;

    MeetingStateEnum() {}

    MeetingStateEnum(Integer value, String desc, String descCN) {
        this.value = value;
        this.desc = desc;
        this.descCN = descCN;
    }

    @JsonValue
    @Override
    public int getValue() {
        return this.value;
    }

    @Override
    public String getDesc() {
        return this.desc;
    }


    @JsonCreator
    public static MeetingStateEnum create(String value) {
        try {
            return MeetingStateEnum.valueOf(value);
        } catch (IllegalArgumentException e) {
            for (MeetingStateEnum meetingStateEnum : MeetingStateEnum.values()) {
                try {
                    if (meetingStateEnum.value == (Integer.parseInt(value))) {
                        return meetingStateEnum;
                    }
                } catch (NumberFormatException n) {
                    if (meetingStateEnum.desc.equals(value)) {
                        return meetingStateEnum;
                    }
                }
            }
            throw new IllegalArgumentException("No element matches " + value);
        }

    }

    @Override
    public String toString() {
        return this.value + "";
    }
}

```

### 2、对于非Json参数，如何自动转换枚举类

> 不是所有的接口参数都像1中是json格式，用`@RequestBody`接收
>
> 例如`form-data`或者`get`方法参数放到路径上时，使用`@RequestParam`接收参数，如果是枚举类型，则会抛出异常。

```java

import com.cetccloud.handler.BaseEnum;
import org.springframework.core.convert.converter.Converter;
import org.springframework.core.convert.converter.ConverterFactory;

import java.util.HashMap;
import java.util.Map;

public class StringToEnumConverterFactory implements ConverterFactory<String, BaseEnum> {

    private static final Map<Class, Converter> converterMap = new HashMap<>();

    @Override
    public <T extends BaseEnum> Converter<String, T> getConverter(Class<T> targetType) {
        Converter<String, T> converter = converterMap.get(targetType);
        if(converter == null) {
            converter = new StringToEnumConverter<>(targetType);
            converterMap.put(targetType, converter);
        }
        return converter;
    }

    class StringToEnumConverter<T extends BaseEnum> implements Converter<String, T> {
        private Map<String, T> enumMap = new HashMap<>();

        StringToEnumConverter(Class<T> enumType) {
            T[] enums = enumType.getEnumConstants();
            for(T e : enums) {
                enumMap.put(String.valueOf(e.getValue()), e);
            }
        }

        @Override
        public T convert(String source) {
            T t = enumMap.get(source);
            if (t == null) {
                throw new IllegalArgumentException("No element matches " + source);
            }
            return t;
        }
    }

}

```



### 3、反序列化时枚举类型自动类型转换

> 枚举类型的数据进行反序列化生成json数据时，如何自动转换成code值
>
> 这里需要使用 `com.fasterxml.jackson.annotation` 下的 `@JsonValue`注解

```json
    @JsonValue
    @Override
    public int getValue() {
        return this.value;
    }
```

